
Object
^
|
Enemy(1 life) --> Boss(Has many lives)
^
|
Fighter(1 life)

BulletF(1life) comes from Fighter


BulletF x Boss, Enemy
Fighter x Boss, Enemy

//Boss will use enemy as weapon. Fighter will use Bullet as Weapon

we have 2 groups(Fighter, BulletF) vs (Enemy, Boss, BulletB)
Then we will draw them again

Only Fighter and BulletF should have explosion effect when they hit the opposite object(Enemy, Boss, BulletB)

4 days to refactor

25-Dec-2025
26-Dec-2025
Understanding

29-Dec-2025
Refactor Logic for checking collision
Refactor Bullet of fighter

30-Dec-2025
Refactor the collision between enemy and Target
Refactor Bullet of Boss to not call constructor too much

============================

void DrawTexturePro(Texture2D texture, Rectangle source, Rectangle dest, Vector2 origin, float rotation, Color tint)
Draw a part of a texture defined by a rectangle with 'pro' parameters
ex: in Tick function of BaseSpace.cpp
    Rectangle source{mFrameX * mWidth+mOffsetX, mFrameY*mHeight, mWidth, mHeight};
    Rectangle dest{mScreenPos.x, mScreenPos.y, mScale*mWidth, mScale*mHeight};
    DrawTexturePro(mImage, source, dest, mOrigin, mfRotation, WHITE);
Draw an mImage(texture data). with source is a rectangle we get from texture data, and write it to dest. origin is the original point that we will use to rotate the image
normally, origin(0,0) that to the top left point of destination.
We can see source with mFrameX is the Frame number in X; mFrameY is frameNumber in y
we have mScale that allow us to scale that Frame in destination rectangle
mOffsetX is an xOffset in the pixel to get the frame in the right center

Dest will be the rectangle in screen, and mOrgigin will be the position where we rotate the frame


we can see in Tick(dT), we have a concept delta time that is the time the computer used to draw the last time.
we can scale with speed(number pixels/s)
 mScreenPos = Vector2Add(mScreenPos, Vector2Scale(Vector2Normalize(mVelocity), mSpeed * aDeltaTime));

 By Sacle Velocity vector with speed * aDeltaTime we can avoid the situation where objects lag
 if CPU took time to draw a frame. I mean the time amounts for drawing frames are not the same
 If we don't use dT, and allow object to move numberofpixel(speed) each Frame we drew => sometimes a frame took more time => object moved a same distance with diffrent amount of time => lag


2 points:
In Tick function of Fighter.cpp
    if(mBouncingTime > 1.0/9.5f ) mSpeed = 500;
	else mSpeed = mOriginSpeed;
   mScreenPos = Vector2Add(mScreenPos, Vector2Scale(Vector2Normalize(mVelocity), mSpeed * aDeltaTime));

-mBouncingTime is not something related to bouncingTime issue; It is just the way we handle when we press a direction key long enough, we will increase the speed.
-Velocity is just the normalized velocity vector to help to define the moving direction of object. To get the value of velocity, we will scale Vector2Normalize(mVelocity) with speed*aDeltaTime to get the distance object will move and its direction also
  then we just use Vector2Add to get the final position of object in screen.
note: screen pos with Vector2 has float value. we will round it to int for the final setting
typedef struct Vector2 {
    float x;                // Vector x component
    float y;                // Vector y component
} Vector2;


==========================
BaseSpace:
    const float mUpdateTIme{1.0/12.0}; ///< time to update animation 
    float mRunningTime{0}; ///< Counting for the time      
    float mSpeed{500.0f};
	float mOriginSpeed{500.0f};
    float mFrameX{}; // which frame  on X axis: the first , second, .etc frame on X axis
	float mFrameY{}; // which frame  on Y axis: the first , second, .etc frame on Y axis
    float mNumberofFrameX{};
    float mNumberofFrameY{};
    Vector2 mScreenPos{}; ///< the position of object in the screen
    //float mWindowWidth{}; // the window width? while don't we use Singleton to get that?
    //float mWindowHeight{};// the window height?
	float mWidth{}; ///< the width of character
	float mHeight{}; ///< the height of character
	float mScale{1.0}; ///< the scale factor of object
	//bool mIsAlive{true}; ///remove this, redundant. when mNumberofLives = 0 => it dies
	uint16_t mNumberofLives{1}; // the number of lives that it can use
	float mOffsetX{};
	float mfRotation{}; ///< float degree ex: -90.0 degree
	Vector2 mVelocity{}; ///< the direction of moving
	Vector2 mOrigin{}; ///< the absolute position of the top left position start with 0,0 

    bool CheckCollision(const BaseSpace& obj);

window: Singleton class// we don't need that because we have GetScreenWidth(0 and GetScreenHeight functions)
  int32_t m_windowWidth;
  int32_t m_windowHeight;


  ====================
DrawTexturePro(mImage, source, dest, mOrigin, mfRotation, WHITE);

  In raylib's DrawTextPro function, the origin parameter defines the pivot point for rotation, specified as an offset relative to the text's top-left corner. The position parameter determines where this calculated pivot point will be placed on the screen. 
How the parameters work together:
position: This Vector2 specifies the screen coordinates where the text will be drawn. Crucially, the final rotated text is positioned such that its origin point aligns with this position.
origin: This Vector2 is an offset relative to the default top-left corner of the text's bounding box (which is (0, 0) by default). This offset is subtracted from the position to determine the actual top-left corner before drawing, and it also serves as the center of rotation.
rotation: This float value (in degrees) is the angle by which the text will be rotated around the specified origin point. 
Common Use Cases for origin:
Default Behavior (Top-Left Rotation): If you want the text to rotate around its top-left corner, set the origin to (0, 0). The position will then refer to the top-left corner of the unrotated text.
Center Rotation: To make the text rotate around its geometric center, you set the origin to half the width and half the height of the text's calculated size. The position will then refer to the center of the text.
... => origin we will move it to the position that we subtract from the default. 